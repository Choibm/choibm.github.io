<!DOCTYPE html>
<html>

<head>
    <style>
        :root {
            --bg-color: #121212;
            --p-color: #e3f2fd;
            --n-color: #f1f8e9;
            --hole-color: #ff5252;
            --electron-color: #448aff;
            --flash-color: #ffeb3b;
        }

        .simulator-container {
            width: 100%;
            max-width: 850px;
            margin: 20px auto;
            background: var(--bg-color);
            color: white;
            padding: 25px;
            border-radius: 15px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-rev {
            background: #d32f2f;
            color: white;
        }

        .btn-eq {
            background: #757575;
            color: white;
        }

        .btn-fwd {
            background: #388e3c;
            color: white;
        }

        .active {
            outline: 3px solid white;
            outline-offset: 2px;
        }

        .diagram-label {
            text-align: center;
            font-size: 0.9rem;
            color: #aaa;
            margin: 10px 0;
        }

        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 5px;
            background: #000;
        }

        #energy-diagram {
            width: 100%;
            height: 280px;
            margin-top: 20px;
            background: #1a1a1a;
            border-radius: 5px;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 0.85rem;
            margin-top: 15px;
            flex-wrap: wrap;
        }
    </style>
</head>

<body>

    <div class="simulator-container">
        <div class="controls">
            <button class="btn btn-rev" onclick="setBias('reverse', this)">Reverse Bias</button>
            <button class="btn btn-eq active" onclick="setBias('equilibrium', this)">Equilibrium</button>
            <button class="btn btn-fwd" onclick="setBias('forward', this)">Forward Bias</button>
        </div>

        <div class="diagram-label">Physical P-N Junction (Recombination Flashes)</div>
        <canvas id="junctionCanvas" width="800" height="240"></canvas>

        <div class="diagram-label">Energy Band Diagram (Correct Fermi Level Split)</div>
        <svg id="energy-diagram" viewBox="0 0 800 280">
            <path id="path-ec" stroke="#fff" fill="transparent" stroke-width="2" />
            <path id="path-ev" stroke="#fff" fill="transparent" stroke-width="2" />

            <path id="path-ef-p" stroke="#ffeb3b" fill="transparent" stroke-width="2" stroke-dasharray="5,5" />
            <path id="path-ef-n" stroke="#ffeb3b" fill="transparent" stroke-width="2" stroke-dasharray="5,5" />

            <text x="10" y="30" fill="white" font-size="12">Ec</text>
            <text x="10" y="270" fill="white" font-size="12">Ev</text>
            <text id="label-efp" x="10" y="0" fill="#ffeb3b" font-size="12">Efp</text>
            <text id="label-efn" x="760" y="0" fill="#ffeb3b" font-size="12">Efn</text>

            <g id="energy-particles"></g>
        </svg>

        <div class="legend">
            <span><b style="color:var(--hole-color)">○</b> Hole</span>
            <span><b style="color:var(--electron-color)">●</b> Electron</span>
            <span><b style="color:var(--flash-color)">★</b> Recombination</span>
            <span style="color:#ffeb3b; border-bottom: 2px dashed #ffeb3b;">-- Fermi Level</span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('junctionCanvas');
        const ctx = canvas.getContext('2d');

        // SVG Elements
        const svgEc = document.getElementById('path-ec');
        const svgEv = document.getElementById('path-ev');
        const svgEfP = document.getElementById('path-ef-p');
        const svgEfN = document.getElementById('path-ef-n');
        const labelEfp = document.getElementById('label-efp');
        const labelEfn = document.getElementById('label-efn');
        const energyParticleG = document.getElementById('energy-particles');

        // Simulation State
        let currentBias = 'equilibrium';
        let depletionWidth = 120;
        let barrierHeight = 60; // Represents the energy difference
        const bandGap = 100;    // Fixed distance between Ec and Ev

        let particles = [];
        let flashes = [];
        let energyParticles = [];

        // --- VISUAL EFFECTS ---
        class Flash {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 1;
                this.opacity = 1.0;
                this.life = 0;
            }
            update() {
                this.radius += 1.5;
                this.opacity -= 0.1;
                this.life++;
            }
            draw() {
                ctx.save();
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 235, 59, ${this.opacity})`;
                ctx.fill();
                ctx.restore();
            }
        }

        // --- PHYSICAL PARTICLE ---
        class Carrier {
            constructor(type, homeSide) {
                this.type = type;
                this.homeSide = homeSide;
                this.initPosition();
                this.opacity = 1.0;
                this.isThermallyGenerated = false; // Add flag
            }

            initPosition() {
                this.y = 40 + Math.random() * 160;
                this.opacity = 1.0;
                if (this.homeSide === 'p') {
                    this.x = Math.random() * (400 - depletionWidth / 2 - 20);
                } else {
                    this.x = (400 + depletionWidth / 2 + 20) + Math.random() * (400 - depletionWidth / 2 - 20);
                }
                this.vx = (Math.random() - 0.5) * 1;
                this.vy = (Math.random() - 0.5) * 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Recombination Logic (Physical)
                let isMinority = (this.type === 'electron' && this.x < 400) || (this.type === 'hole' && this.x > 400);

                if (isMinority && currentBias === 'forward') {
                    this.opacity -= 0.03;
                    if (this.opacity <= 0) {
                        flashes.push(new Flash(this.x, this.y));
                        this.initPosition();
                        return;
                    }
                } else {
                    if (this.opacity < 1.0) this.opacity = 1.0;
                }

                // --- MOVEMENT LOGIC ---
                if (currentBias === 'forward') {
                    if (this.type === 'hole') this.x += 1.5;
                    if (this.type === 'electron') this.x -= 1.5;
                    if (this.x > 800 || this.x < 0) this.initPosition();
                }
                else if (currentBias === 'reverse') {
                    // --- CORRECTED "SWEEPING" PHYSICS ---
                    const depletionLeft = 400 - depletionWidth / 2;
                    const depletionRight = 400 + depletionWidth / 2;

                    if (this.type === 'hole') {
                        // Hole moves LEFT (N -> P)
                        // If hole is inside the Field OR on the N-side (Minority), it SWEEPS
                        if (this.x > depletionLeft) {
                            this.x -= 15; // Fast Sweep
                        } else {
                            this.x -= 1; // Slow Extraction
                        }

                        if (this.x < 10 && !this.isThermallyGenerated) this.vx *= -1;
                    }
                    else { // Electron
                        // Electron moves RIGHT (P -> N)
                        // If electron is inside the Field OR on the P-side (Minority), it SWEEPS
                        if (this.x < depletionRight) {
                            this.x += 15; // Fast Sweep
                        } else {
                            this.x += 1; // Slow Extraction
                        }

                        if (this.x > 790 && !this.isThermallyGenerated) this.vx *= -1;
                    }
                }
                else { // Equilibrium
                    const pBoundary = 400 - depletionWidth / 2;
                    const nBoundary = 400 + depletionWidth / 2;
                    if (this.homeSide === 'p' && this.x > pBoundary) this.vx *= -1;
                    if (this.homeSide === 'n' && this.x < nBoundary) this.vx *= -1;
                }

                if (this.y < 40 || this.y > 220) this.vy *= -1;
                if (this.x < 5 || this.x > 795) this.vx *= -1;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                if (this.type === 'hole') {
                    ctx.strokeStyle = '#ff5252';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    ctx.fillStyle = '#448aff';
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        // --- ENERGY BAND PARTICLE ---
        class EnergyParticle {
            constructor(type, band) {
                this.type = type;
                this.band = band;
                this.el = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                this.el.setAttribute("r", "5");
                if (type === 'hole') {
                    this.el.setAttribute("stroke", "#ff5252");
                    this.el.setAttribute("stroke-width", "2");
                    this.el.setAttribute("fill", "none");
                } else {
                    this.el.setAttribute("fill", "#448aff");
                }
                energyParticleG.appendChild(this.el);
                this.recombining = false;
                this.opacity = 1.0;
                this.reset();
            }

            reset() {
                this.recombining = false;
                this.opacity = 1.0;
                this.el.setAttribute("opacity", this.opacity);
                if (this.type === 'electron') this.x = 450 + Math.random() * 350;
                else this.x = Math.random() * 350;
            }

            update() {
                const mid = 400;
                const w = depletionWidth / 2;
                const h = barrierHeight;
                const ecP_y = 50;
                const ecN_y = 50 + h;

                let bandY = ecP_y;
                if (this.band === 'ev') bandY += bandGap;

                if (this.x > mid + w) {
                    if (this.band === 'ec') bandY = ecN_y;
                    if (this.band === 'ev') bandY = ecN_y + bandGap;
                } else if (this.x > mid - w) {
                    const percent = (this.x - (mid - w)) / (2 * w);
                    let baseEc = ecP_y + (h * percent);
                    if (this.band === 'ec') bandY = baseEc;
                    if (this.band === 'ev') bandY = baseEc + bandGap;
                }

                if (!this.recombining) {
                    if (this.type === 'electron') this.y = bandY - 8;
                    else this.y = bandY + 8;
                }

                if (currentBias === 'forward') {
                    if (this.type === 'electron') this.x -= 2;
                    else this.x += 2;

                    if (!this.recombining && ((this.type === 'electron' && this.x < mid) || (this.type === 'hole' && this.x > mid))) {
                        this.recombining = true;
                    }

                    if (this.recombining) {
                        if (this.type === 'electron') this.y += 1.5;
                        else this.y -= 1.5;
                        this.opacity -= 0.04;
                        if (this.opacity <= 0) {
                            this.reset();
                            return;
                        }
                    }
                    if (this.x < 0 || this.x > 800) this.reset();

                } else if (currentBias === 'reverse') {
                    this.recombining = false;
                    if (this.type === 'electron') {
                        this.x += 1; if (this.x > 790) this.x = 790;
                    } else {
                        this.x -= 1; if (this.x < 10) this.x = 10;
                    }
                } else {
                    this.recombining = false;
                    if (this.type === 'electron') {
                        this.x += (Math.random() - 0.5) * 2;
                        if (this.x < mid + w) this.x += 2;
                    } else {
                        this.x += (Math.random() - 0.5) * 2;
                        if (this.x > mid - w) this.x -= 2;
                    }
                }

                this.el.setAttribute("cx", this.x);
                this.el.setAttribute("cy", this.y);
                this.el.setAttribute("opacity", this.opacity);
            }
        }

        // --- HELPER: THERMAL GENERATION ---
        function generateThermalCarriers() {
            if (currentBias !== 'reverse') return;

            // Small probability to generate a carrier (Leakage Current)
            if (Math.random() < 0.05) {
                // Generate Minority Electron in P-side
                let pElectron = new Carrier('electron', 'p');
                pElectron.x = 400 - depletionWidth / 2 - 10; // Start just left of depletion
                pElectron.y = 40 + Math.random() * 160;
                pElectron.isThermallyGenerated = true;
                particles.push(pElectron);
            }

            if (Math.random() < 0.05) {
                // Generate Minority Hole in N-side
                let nHole = new Carrier('hole', 'n');
                nHole.x = 400 + depletionWidth / 2 + 10; // Start just right of depletion
                nHole.y = 40 + Math.random() * 160;
                nHole.isThermallyGenerated = true;
                particles.push(nHole);
            }
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < 30; i++) particles.push(new Carrier('hole', 'p'));
            for (let i = 0; i < 30; i++) particles.push(new Carrier('electron', 'n'));

            while (energyParticleG.firstChild) {
                energyParticleG.removeChild(energyParticleG.lastChild);
            }
            energyParticles = [];
            for (let i = 0; i < 15; i++) energyParticles.push(new EnergyParticle('electron', 'ec'));
            for (let i = 0; i < 15; i++) energyParticles.push(new EnergyParticle('hole', 'ev'));
        }

        function setBias(mode, btn) {
            currentBias = mode;
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            if (mode === 'forward') {
                depletionWidth = 40;
                barrierHeight = 10;
            } else if (mode === 'reverse') {
                depletionWidth = 240;
                barrierHeight = 140;
            } else {
                depletionWidth = 120;
                barrierHeight = 70;
            }
            energyParticles.forEach(p => p.reset());
            // Clean up thermal particles when switching modes
            particles = particles.filter(p => !p.isThermallyGenerated);
            // If we lost too many particles due to thermal drift, refill majorities
            if (particles.length < 60) initParticles();
        }

        function drawStructure() {
            ctx.fillStyle = '#0d47a1';
            ctx.fillRect(0, 0, 400, 240);
            ctx.fillStyle = '#1b5e20';
            ctx.fillRect(400, 0, 400, 240);
            ctx.fillStyle = 'rgba(200, 200, 200, 0.4)';
            ctx.fillRect(400 - depletionWidth / 2, 0, depletionWidth, 240);

            ctx.font = "bold 14px Arial"; ctx.textAlign = "center";
            ctx.fillStyle = "#ffccbc";
            for (let i = 1; i < 4; i++) {
                for (let j = 1; j < 4; j++) {
                    let x = 400 - (depletionWidth / 4) * i;
                    if (x > 400 - depletionWidth / 2) ctx.fillText("-", x, 60 * j);
                }
            }
            ctx.fillStyle = "#c8e6c9";
            for (let i = 1; i < 4; i++) {
                for (let j = 1; j < 4; j++) {
                    let x = 400 + (depletionWidth / 4) * i;
                    if (x < 400 + depletionWidth / 2) ctx.fillText("+", x, 60 * j);
                }
            }
            ctx.fillStyle = "white";
            ctx.fillText("P-TYPE", 50, 30);
            ctx.fillText("N-TYPE", 750, 30);
        }

        function updateEnergyDiagram() {
            const mid = 400;
            const w = depletionWidth / 2;
            const h = barrierHeight;

            const generatePath = (offset) => {
                return `M 0 ${50 + offset} 
                    L ${mid - w} ${50 + offset} 
                    C ${mid} ${50 + offset}, ${mid} ${50 + h + offset}, ${mid + w} ${50 + h + offset} 
                    L 800 ${50 + h + offset}`;
            };

            svgEc.setAttribute('d', generatePath(0));
            svgEv.setAttribute('d', generatePath(bandGap));

            const ef_p_y = 50 + bandGap - 15;
            const ef_n_y = (50 + h) + 15;

            svgEfP.setAttribute('d', `M 0 ${ef_p_y} L ${mid} ${ef_p_y}`);
            labelEfp.setAttribute('y', ef_p_y - 5);

            svgEfN.setAttribute('d', `M 800 ${ef_n_y} L ${mid} ${ef_n_y}`);
            labelEfn.setAttribute('y', ef_n_y - 5);
        }

        function animate() {
            ctx.clearRect(0, 0, 800, 240);
            drawStructure();

            // Generate leakage current particles
            generateThermalCarriers();

            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.update();
                p.draw();

                // Remove thermal particles that drifted off screen
                if (p.isThermallyGenerated && (p.x < 0 || p.x > 800)) {
                    particles.splice(i, 1);
                }
            }

            for (let i = flashes.length - 1; i >= 0; i--) {
                flashes[i].update();
                flashes[i].draw();
                if (flashes[i].life > 10) flashes.splice(i, 1);
            }
            energyParticles.forEach(p => { p.update(); });
            updateEnergyDiagram();
            requestAnimationFrame(animate);
        }

        initParticles();
        animate();
    </script>

</body>

</html>